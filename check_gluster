#!/usr/bin/ruby -w

# We use old ruby 1.8.7
# rubocop:disable Style/HashSyntax

# We match all exceptions except SystemExit to redefine exit status for nagios
# rubocop:disable Lint/RescueException

# Other disables
# rubocop:disable Metrics/AbcSize, Metrics/LineLength, Metrics/MethodLength, Metrics/ClassLength

# Nagios exit codes
module NagiosStatus
  OK = 0
  WARNING = 1
  CRITICAL = 2
end

# Top level module
module CheckGluster
  require 'optparse'

  PARAMS = {
    # gluster command
    :gluster_command => '/usr/sbin/gluster',
    :glusterd_pid_path => '/var/run/glusterd.pid',
    # Daemons to check with gluster volume status
    :check_running_daemons => {
      'bitrot' => ['Bitrot Daemon', 'Scrubber Daemon'],
      'heal' => ['Self-heal Daemon'],
      'nfs' => ['NFS Server']
    }
  }.freeze

  # Parse command line options
  class OptionsParser
    @checks = PARAMS[:check_running_daemons].keys
    private_class_method :new
    attr_reader :checks

    def self.parse
      option_parser = OptionParser.new

      option_parser.on(
        '-c',
        '--checks ' + @checks.join(','),
        Array,
        'Checks to run. Default is ' + @checks.join(',')
      ) do |list|
        list.each do |check|
          raise OptionParser::InvalidOption, check.to_s unless @checks.include? check
        end
        @checks = list
      end

      begin
        option_parser.parse!
        @checks
      rescue OptionParser::InvalidOption, OptionParser::MissingArgument, OptionParser::InvalidArgument => ex
        puts "Error: #{ex.message}"
        puts option_parser.help
        exit(NagiosStatus::CRITICAL)
      end
    end
  end

  # Actual check class
  class Check
    begin
      require 'open3'
      require 'rubygems'
      $VERBOSE = nil
      require 'crack'
      $VERBOSE = true
      require 'socket'
    rescue Exception => ex
      puts ex.message
      exit(NagiosStatus::CRITICAL)
    end

    def check_glusterd
      pid = File.open(PARAMS[:glusterd_pid_path], &:readline).to_i
      Process.kill('CHLD', pid)
    rescue Errno::ESRCH
      raise 'Glusterd is not running'
    end

    def get_services_from_checks(checks)
      services = []
      checks.each do |check|
        PARAMS[:check_running_daemons][check].each do |service|
          services.concat(any_to_array(service))
        end
      end
      services
    end

    def gluster(command, xml = true)
      data = { 'stdout' => '', 'error' => '', 'status' => 1 }
      command = '--xml ' + command if xml
      Open3.popen3(PARAMS[:gluster_command] + ' ' + command) do |stdin, stdout, stderr, wait_thr|
        stdin.close
        data['stdout'] = stdout.read
        data['sterr'] = stderr.read
        data['status'] = wait_thr.value
      end
      raise data['status'].to_s + ' : ' + data['stdout'] unless data['status'].success?
      return data['stdout'] unless xml
      data = Crack::XML.parse(data['stdout'])
      if data['cliOutput']['opRet'].to_i != 0 || data['cliOutput']['opErrno'].to_i != 0
        raise "Error on #{command} : #{data['cliOutput']['opErrstr']}"
      end
      data['cliOutput']
    end

    def peer_status
      peers = gluster('peer status')['peerStatus']['peer']
      peers = any_to_array(peers)
      peers.each do |peer|
        raise "#{peer['hostname']} is disconnected" unless peer['connected'].to_i == 1
        raise "#{peer['hostname']} has wrong state #{peer['state']}" unless peer['state'].to_i == 3
      end
    end

    def pool_list
      peers = gluster('pool list')['peerStatus']['peer']
      peers = any_to_array(peers)
      peers.each do |peer|
        raise "#{peer['hostname']} is disconnected" unless peer['connected'].to_i == 1
        raise "#{peer['hostname']} has wrong state #{peer['state']}" if peer['hostname'] != 'localhost' && peer['state'].to_i != 3
      end
    end

    def volume_list
      volumes = gluster('volume list')['volList']['volume']
      any_to_array(volumes)
    end

    def volume_info(volume)
      volume = gluster("volume info #{volume}")['volInfo']['volumes']['volume']
      raise "volume #{volume['name']} is stopped" unless volume['status'].to_i == 1
      # volume info is not well formated XML
      volume['bricks']['brick'].map { |s| s.gsub(/<name>.*/, '').split(':') }
    end

    def volume_status(volume, bricks, checks)
      nodes = gluster("volume status #{volume}")['volStatus']['volumes']['volume']['node']
      nodes = any_to_array(nodes)
      nodes.each { |node| node['path'] = Socket.gethostname if node['path'] == 'localhost' }
      # Checking that all processes are running
      nodes.each do |node|
        raise "process #{node['hostname']}:#{node['path']} is not online" if node['status'].to_i != 1
      end
      # Check that all bricks are running
      bricks.each do |brick|
        raise "volume #{brick[0]}:#{brick[1]} is not running" unless check_running(nodes, brick[0], brick[1])
        # Check that is running
        get_services_from_checks(checks).each do |daemon|
          raise "Daemon #{brick[0]}:\"#{daemon}\" is not started" unless check_running(nodes, daemon, brick[0])
        end
      end
    end

    def check_running(nodes, hostname, path)
      nodes.each do |node|
        return true if node['hostname'] == hostname && node['path'] == path
      end
      false
    end

    def volume_heal_info(volume)
      info = gluster("volume heal #{volume} info", false).split("\n")
      parse_heal(info).each do |brick, data|
        raise "Brick #{brick} is disconnected" unless data['status']
        raise "Brick #{brick} is split-brained" unless data['entries'] == 0
      end
    end

    def parse_heal(info)
      bricks = {}
      brick = ''
      info.each do |line|
        if line =~ /^Brick /
          brick = line.gsub(/^Brick /, '')
          bricks[brick] = { 'data' => [] }
        elsif line =~ /^Status: Connected/
          bricks[brick]['status'] = true
        elsif line =~ /^Status.*/
          bricks[brick]['status'] = false
        elsif line =~ /^Number of entries: /
          bricks[brick]['entries'] = line.gsub(/^Number of entries: /, '').to_i
        else
          bricks[brick]['data'].push(line)
        end
      end
      bricks
    end

    def volume_bitrot_scrub_status(volume)
      info = gluster("volume bitrot #{volume} scrub status", false).split("\n")
      status = parse_bitrot_status(info)
      raise 'BitRot is not enabled' unless status['state']
      status['nodes'].each do |node, _v|
        raise "BitRot error on #{node}" unless status['nodes'][node]['errors'] == 0
      end
    end

    def parse_bitrot_status(info)
      info.map! { |s| s.gsub(/localhost/, Socket.gethostname) }
      status = { 'state' => false, 'nodes' => {} }
      node = ''
      info.each do |line|
        if line =~ /^State of scrub: Active/
          status['state'] = true
        elsif line =~ /^Node: /
          node = line.gsub(/^Node: /, '')
          status['nodes'][node] = {}
        elsif line =~ /^Error count: /
          status['nodes'][node]['errors'] = line.gsub(/^Error count: /, '').to_i
        end
      end
      status
    end

    def any_to_array(any)
      return [any] if any.class.to_s != 'Array'
      any
    end

    private :get_services_from_checks, :gluster, :any_to_array
    private :check_running, :parse_heal, :parse_bitrot_status
  end
end

begin
  # Parse parameters
  checks = CheckGluster::OptionsParser.parse

  # Run gluster checks
  gluster_check = CheckGluster::Check.new
  gluster_check.check_glusterd
  gluster_check.peer_status
  gluster_check.pool_list
  gluster_check.volume_list.each do |volume|
    bricks = gluster_check.volume_info(volume)
    gluster_check.volume_status(volume, bricks, checks)
    gluster_check.volume_heal_info(volume) if checks.include? 'heal'
    gluster_check.volume_bitrot_scrub_status(volume) if checks.include? 'bitrot'
  end

  puts 'OK: Gluster cluster is healthy'
  exit(NagiosStatus::OK)
# Normal exit
rescue SystemExit => ex
  raise ex
# Anything else goes to nagios error with critial status
rescue Exception => ex
  puts "Error: #{ex.message}"
  exit(NagiosStatus::CRITICAL)
end

# rubocop:enable all
